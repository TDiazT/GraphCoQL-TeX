\documentclass[sigplan,10pt,anonymous,review,nonacm]{acmart}
% \settopmatter{printfolios=true,printccs=false,printacmref=false}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{multicol}
\usepackage[cache=false]{minted}
\usepackage{listings}
%\usepackage{xcolor}
\usepackage[nounderscore]{syntax}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{stmaryrd}
\usepackage{newunicodechar}
\newunicodechar{ə}{\pmschwa}
\DeclareRobustCommand{\pmschwa}{\rotatebox[origin=c]{180}{e}}


% Minted options
\setminted{fontsize=\footnotesize}
\definecolor{coqbg}{rgb}{0.95,0.95,0.95}


% Colors
\definecolor{darkgray}{HTML}{404040}
\definecolor{rulegray}{HTML}{DADADA}
\definecolor{keywordblue}{HTML}{1F497C}
\definecolor{mygray}{gray}{0.6}
% Listings
\lstdefinestyle{code}{
  basicstyle=\scriptsize,
  %backgroundcolor=\color{rulegray},
   numbers=left,
  emph=[1]{BEGIN, END, INPUT},
  emphstyle=[1]{\color{black}},
  keywordstyle=\color{keywordblue},
  keywords={LET, IN,CASE,IF,ELSE,THEN, WITH},
  escapeinside={(*@}{@*)}
}
% Listings
%\lstdefinestyle{code}{
  %basicstyle=\scriptsize,
  %keywordstyle=\color{keywordblue},
  %keywords={import,qualified,as,do,where}
%}


\newcommand{\mynote}[3]
    {{\color{#3} \fbox{\bfseries\sffamily\scriptsize#1}
    {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}}~}
\newcommand{\et}[1]{\mynote{ET}{#1}{purple}}
\newcommand{\fo}[1]{\mynote{FO}{#1}{brown}}
\newcommand{\td}[1]{\mynote{TD}{#1}{blue}}

\newcommand\mdoubleplus{\mathbin{+\mkern-5mu+}}

% naming
\newcommand{\plstyle}[1]{\mbox{\textsc{#1}}\xspace}
\newcommand{\gql}{\plstyle{GraphQL}}
\newcommand{\gcoql}{\plstyle{GraphCoQL}}
\newcommand{\spec}{\plstyle{Spec}}
\newcommand{\HP}{\plstyle{H\&P}}
\newcommand{\json}{\plstyle{JSON}}
\newcommand{\jscert}{\plstyle{JSCert}}
\newcommand{\coqr}{\plstyle{CoqR}}
\newcommand{\coq}{\plstyle{Coq}}
\newcommand{\ssreflect}{\plstyle{Ssreflect}}
\newcommand{\mathcomp}{\plstyle{Mathematical Components}}
\newcommand{\equations}{\plstyle{Equations}}
\newcommand{\Vals}{$\mathit{Vals}$\xspace}

% math naming 
\newcommand{\query}{\varphi}
\newcommand{\sset}{\overline{\sigma}}
\newcommand{\sel}{\sigma}
\newcommand{\schema}{\mathcal{S}\xspace}
\newcommand{\graph}{\mathcal{G}\xspace}

\newcommand{\response}{\rho}

% semantics
\newcommand{\filter}[2]{\mathit{filter}_{#2}(#1)}

\newcommand{\eval}[2]{\llbracket #1 \rrbracket^{#2}_{G}}
\newcommand{\evalu}[1]{\eval{#1}{u}}
\newcommand{\evalfilteru}[2]{\eval{\mathit{filter}_{#2}(#1)}{u}}
% simpl semantics
\newcommand{\seval}[2]{\llparenthesis #1 \rrparenthesis^{#2}_{G}}
\newcommand{\sevalu}[1]{\seval{#1}{u}}

\newcommand{\queries}{\overline{\varphi}}
\newcommand{\subqueries}[1]{\overline{#1}}
\newcommand{\fkey}{\texttt{f}}

%selections
\newcommand{\args}{\overline{\alpha}}
\newcommand{\fld}{\texttt{f[}\args\texttt{]}}
\newcommand{\afld}{\texttt{a:}\fld}

\newcommand{\nfld}[1]{\fld\; \texttt{\{}#1\texttt{\}} }
\newcommand{\anfld}[1]{\afld\; \texttt{\{}#1\texttt{\}} }

\newcommand{\ifrag}[2]{\texttt{... on #1 \{}#2\texttt{\}}}
\newcommand{\resp}[1]{\fkey\texttt{:}#1}
\newcommand{\nval}{\texttt{null}}
\newcommand{\val}{\texttt{v}}

%normalize
\newcommand{\normalize}[1]{\mathit{normalize (#1)}}

%misc
\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\wrt}{w.r.t.\@\xspace}
\newcommand{\eg}{e.g.\@\xspace}
\newcommand{\cf}{cf.\@\xspace}
\newcommand{\viz}{viz.\@\xspace}
\newcommand{\etal}{et al.\@\xspace}


\begin{document}

\title{A Mechanized Formalization of \gql}
\author{Tomás Díaz}
\affiliation{%
  \institution{IMFD Chile}
  \city{Santiago}
  \country{Chile}
}

\author{Federico Olmedo}
\affiliation{%<
  \institution{University of Chile \& IMFD Chile}
  \department{Computer Science Department (DCC)}
  \city{Santiago}
  \country{Chile}
}
\author{Éric Tanter}
\affiliation{%
  \institution{University of Chile \& IMFD Chile}
  \department{Computer Science Department (DCC)}
  \city{Santiago}
  \country{Chile}
}

\begin{abstract}
\gql is a novel language for specifying and querying web APIs, allowing clients to flexibility and efficiently retrieve data of interest. The \gql language specification is unfortunately only available in prose, making it hard to develop robust formal results for this language. Recently, Hartig and Pérez proposed a formal semantics for \gql in order to study the complexity of \gql queries. These semantics are however not mechanized and leave certain key aspects unverified. We present \gcoql, the first mechanized formalization of \gql, developed in the \coq proof assistant.  \gcoql covers the schema definition DSL, query definitions, validation of both schema and queries, as well as the semantics of queries over a graph data model.
We illustrate the application of \gcoql by formalizing the key query transformation and interpretation techniques of Hartig and Pérez, and proving them correct, after addressing some imprecisions and minor issues. 
We hope that \gcoql can serve as a solid formal baseline for both language design and verification efforts for \gql.
\end{abstract}


\maketitle


\input{introduction.tex}
\input{background.tex}
\input{formalization.tex}
\input{normalization.tex}
%\input{discussion.tex}

\section{Validation}\label{sec:valid}
%\td{This was supposed to be a mention to the examples implemented in our system - HP, spec's, etc}

%\et{expand a bit on what you have to say about the examples}

To validate that \gcoql adequately captures the semantics of \gql, in additional to establishing an eyeball correspondence with \spec, 
we implemented several examples, coming from four different sources.\et{you say four sources, but below there is only three}

First, We implemented a subset of the examples used in the \spec validation section (\cf\S5~\cite{gqlspec}).
We include 41 of the 92 total examples present in that section.\et{this is not a very good number. Can you get it up by the deadline? or give better evidence that the subset includes the most important ones?}
The large majority of the examples that we have not implemented correspond to 
variables validation (31 cases) and fragments (29)\td{Some of these are tests that overlap with the inline fragments -- So we are still kind of testing them}
\td{The cases that are exclusive to fragments are 8}\td{Also, some cases use fragment only as a way to write the tests, but they are not really necessary
(they are not testing things from the fragments) so I don't consider them}.
\td{The rest of cases are a mix of things -- 11 are related to operations (\eg no two queries with the same name, no named query + another unnamed query, etc)}

\et{relate to the limitations below: of course you can't include examples that require unsupported features. Is it as simple as saying that you have implemented all examples that do not require such features?}

\et{move limitations section to above, and allude to limitations when discussing what has (not) been included in the tests.}

\et{try to put some "positive characterization" of what the implemented examples cover}

Second, we implemented the example used in \HP, from its schema to its graph, query and corresponding response. 
We define the values in $\mathit{Vals}$ as elements of an inductive type, which wraps already defined types in Coq
(such as integer, string, etc.), and a coercion function to transform them into the matching JSON format.




\iffalse
	-	Only executable definitions when evaluating = -1 (text + query)
	- Uniqueness of operation = -3
	- Anonymous operation = -2
	- Suscription = -5 (single root field)
	- Fields = 2 + 2 + 2 - 1 (introspection on union)
	- Field merging = 3 + 1 - 1 (variable) + 2 - 2  (variables) + 2  + 1
	- Leaf fields = 2 + 3 - 1 (type ext)
	- Argument names = 2 - 1 (directives) + 1 - 1 (directives) + 2  - 1 (type extension)
	- Required args = -5 (required arguments - non-null + default values)
	- Fragment uniqueness = -2 (fragments)
	- Fragment spread type existence = 1 - 3 (2 fragments y 1 directive) + 1 - 2 (fragments)
	- Fragments on comp types = 3 - 3 (fragments) + 2 - 2 (fragments)
	- Fragments must be used = -1
	- Fragments spread = -4 (fragments) + 2 - 2 (fragments) + 1 - 2 (fragments) + 1 - 2 (fragments) + 2 - 2  + 2 - 2 + 1 - 2 + 1 - 2 
	- Valid Input values = -5
	- Input objects = -3
	- Directives = -3
	- Variables = - 2 - 8 - 7 - 4 - 7
	
	Hechos : 2 + 2 + 2 + 3 + 1 + 2 + 2 + 2 + 3 + 2 + 1 + 2  + 1 + 1 + 3 + 2 + 2 + 1 + 1 + 2 + 2 + 1 + 1 = 41
	No hechos : -1 - 3 - 2 - 5 - 1 - 1 - 2 - 1 - 1 - 1 - 1 - 5 - 2 - 3 - 2 - 3 - 2  - 1 - 2 - 2 - 2 - 2 - 2 - 2 -2 - 2 - 5 - 3 - 3 - 2 - 8 - 7 - 4 - 7  = 92
	- Variables = -1 - 2 - 2 - 8 - 7 - 4 - 7 = 31
	- Fragments = -2 - 2 - 2 - 3 - 2 - 1 - 4 - 2 - 2 - 2 - 2 - 2 - 1 - 2 = 29 
	- Operations = -1 - 3 - 2 - 5 = 11
	- Directives = -1 -1 - 1 - 3 = 6
	- Valid input values = 5
\fi 
	
Finally, we also partially\et{is it only the error stuff that's missing?} implemented the Star Wars example defined in the reference implementation of \gql\footnote{https://github.com/graphql/graphql-js/tree/master/src/\_\_tests\_\_}.
We include the schema definition, except for the \texttt{secretBackstory} field which resolves to an error\td{Bc we are not handling errors}. The data modeled as a graph and 
evaluation of 9 queries (out of a total of 17), comparing them to the expected outputs. Of the not implemented cases, 3 correspond to errors, 2 to introspection, 1 to fragments, 2 to variables and 
one where execution is over an object with named properties\td{Idk, something more specific to JS than \gql}.
\td{There are 7 other about validation, which I didn't notice, but I can add them}
\td{In that same repo (https://github.com/graphql/graphql-js/tree/master/src) each subfolder (type, execution, etc) contain other \_\_tests\_\_ folders, but
I didn't delve too much into them -- some are a bit too particular to JS. They can still be adapted, but not now}
		

% Most of the development time was spent in the definition and proofs of normalization.
% We initially worked on the semantics as specified by \cite{gqlph}

%\et{have a brief section on limitations that lists everything from the spec that is not covered currently in \gcoql (operations beyond query, errors, etc)}

\input{limitations.tex}
\input{related.tex}
\input{conclusions.tex}

\clearpage
\bibliographystyle{acm}
\bibliography{biblio}
\end{document}
