
\section{Introduction}

GraphQL is a technology-agnostic framework that provides a common language to define interfaces to services' data and to query them. It has been mainly proposed as a new alternative to RESTful Web Services. After being used internally in Facebook for three years, in 2015 they released a specification and a reference implementation. Since its release, GraphQL has seen a huge increase in popularity, with major firms such as Coursera, Github and Airbnb incorporating it to their services. Early on 2019, it became an independent foundation, separating itself from Facebook. Some of its strong appeals are that many REST requests can be replaced by a single GraphQL query and that queries follow a ``what you ask is what you get'' spirit. This means that you can be very precise with the data you request and the response you get will look very similar to the query.

GraphQL has a specification where it describes its main components. We will refer to it as the \textit{Spec} throughout the paper. This document includes definitions for the query language and validation processes, amongst other things. The specification actively undergoes revisions, with an open working group that regularly meets every month to discuss related issues and improvements. These include extending the language to support new features or fix posible ambiguities present in the document. There is also a project to define CATs\footnote{Compatibility Acceptante Tests} for the different languages and frameworks that implement GraphQL\td{Not sure if this should go or where. It may serve as a link to "why of GraphCoQL"}. This is because the document is written in plain english and does not include a rigorous formalization of its inner mechanics and limitations.

Along this line, Hartig and PÃ©rez proposed the first (and so far only) formalization of GraphQL and its semantics\cite{gqlph}. We will refer to it as \textit{HP} throughout the paper. They define their semantics by using a graph as the underlying data model over which queries are evaluated. This allows  them to then establish some properties and transformations over queries. These properties and transformations are essential for their posterior results, in which they prove complexity boundaries for GraphQL queries. This work serves as a first step to XX. However, this formalization is purely theoretical.

Seeing that the rise of proof assistants is at hand, with notorious projects such as X, Y and Z, we decided to embark on a journey. We believe that GraphQL is still a very young and active technology which could benefit greatly by having its specification mechanically verified from its early stages. Its scope is not so vast that it cannot be formalized, and it is still growing and with open questions. We therefore decided to implement \textit{GraphCoQL}\footnote{The ``CoQ'' part is pronounced as ``Coq'', not pronouncing the ``Q'' separately as in ``GraphQL''.}, which formalizes GraphQL and its semantics in Coq. 

Our implementation tries to match the Spec's definitions whenever it is possible. This provides a component of trustworthiness given by an eye-ball correspondance, following the examples of X, Y, Z. When it comes to the underlying data model, we follow the example of HP and define our semantics in a graph setting. We were also interested in defining the properties and transformation rules defined by HP. These definitions and their proofs of correctness are fundamental in the posterior results they obtain. This served as a particularly interesting first case study for our system, to establish that we can actually reason about GraphQL and that theirs results were based off correct assumptions. This allows us to, hopefully, anticipate that other transformations may also be defined and proven correct in GraphCoQL.

For our development, the use of the \textit{Equations} library to define non-structural recursive functions was crucial. Other libraries, such as \textit{Function} and \textit{Program} did not provide sufficient tools to handle rewriting and inductive reasoning of our definitions, which \textit{Equations} incredibly facilitates. We also made heavy use of SSReflect and their mindset of keeping everything in Set (not entirely sure if this is true...  but at least they transmit this). We were first motivated to use it to define the graphs and try to narrow our scope to finite types, as was used by (Veronique, Ev, Emilio, Dumbrava). We did not  end up using any of it but the mindset behind it was kept (the Set part). The computational aspect of SSReflect facilitated proofs very much.
Finally, we have not extracted it to another language but everything is implemented in \texttt{Set}, so it should be simple to do.

\subsubsection*{Contributions}
The main contributions of this work are:
\begin{enumerate}
    \item The first formalization in Coq of GraphQL. This includes the definition for schema's DSL, query definition, schema and query validation, and its semantics over a graph data model. 
    \item Detection and correction of unsound definitions in PH.
    \item The implementation of a normalization function with proofs of its correctness and preservation of semantics. This is a fundamental statement and result used by PH to prove complexity results about GraphQL queries.
    \item Proof of equivalence between the semantics and a simplified version. This is also an important result for posterior analysis made in PH.
    
\end{enumerate}

\subsubsection*{Structure of this paper}

We first begin by gently and briefly introducing GraphQL in section \ref{sec:bg}, which we do by means of an example. Then, in section \ref{sec:form}, we describe the basic building blocks of our formalization. This includes the definition of a GraphQL schema, the graph data model, queries and their semantics. From there, we move onto section \ref{sec:norm} where we describe the normalization process and proofs of its correctness and preservation of semantics. We finalize that section with the definition of the simplified semantics, as described in PH, and a proof of equivalence between the semantics defined in section \ref{sec:form} and the simplified one. In section \ref{sec:valid}, we describe some of the things we did to validate our work and finally in section \ref{sec:related} and \ref{sec:future} we discuss related and future work.

